---
title: "SAASI Simulation Study"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{SAASI Simulation Study}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 8,
  fig.height = 6,
  warning = FALSE,
  message = FALSE
)
```

## Introduction

This vignette demonstrates the accuracy of SAASI (Sampling-Aware Ancestral State Inference) through simulation studies. We simulate phylogenetic trees with known ancestral states using a birth-death-sampling process, then assess how well SAASI can recover the internal states.

## Setup

Load required packages:

```{r libraries}
library(saasi)
```

## Simulation Parameters

We use a 3-state model with heterogeneous sampling rates to test SAASI's ability to handle sampling bias:

```{r parameters}
# Define birth-death-sampling parameters
demo_pars <- data.frame(
  state = c("1", "2", "3"), 
  rootprior = c(1/3, 1/3, 1/3), 
  lambda = c(3, 1.5, 1.5),      # Birth rate
  mu = c(0.1, 0.1, 0.1),          # Death rate
  psi = c(0.1, 1.0, 1.0)          # Sampling rate (heterogeneous!)
)

# Define transition rate matrix Q
demo_Q <- matrix(0.3, 3, 3)
diag(demo_Q) <- -0.6
rownames(demo_Q) <- c("1", "2", "3")
colnames(demo_Q) <- c("1", "2", "3")

```

**Key feature:** State 1 has a sampling rate of 0.1, while states 2 and 3 have sampling rates of 1.0. This creates sampling bias that SAASI is designed to handle.

## Single Simulation Example

First, let's demonstrate a single simulation to understand the workflow:

```{r single_simulation}
set.seed(123)

# Generate tree with built-in post-processing
phy <- sim_bds_tree(
  params_df = demo_pars, 
  q_matrix = demo_Q, 
  x0 = 1,                    # Start at state 1
  max_taxa = 500,             # Initial tree size
  max_t = 50,                # Maximum time depth
  min_tip = 100               # Minimum tips after post-processing
)
```

Extract true ancestral states (ground truth):

```{r extract_truth}
# The true internal node states are stored in node.state
true_states <- phy$node.state
```

Run SAASI to infer ancestral states:

```{r run_saasi_single}
# Run SAASI

saasi_result <- saasi(phy = phy,              # phylogenetic tree
                     q_matrix = demo_Q,       # transition rate matrix
                     lambda = c(3, 1.5, 1.5), # speciation rate
                     mu = 0.1,                # extinction rate
                     psi = c(0.1,1.0,1.0),    # sampling rate
                     prior = NULL)  
```

Calculate accuracy:

```{r accuracy_single}
predicted_states <- apply(saasi_result, 1, which.max)

# Calculate accuracy
accuracy <- mean(predicted_states == true_states)
cat("Accuracy for this simulation:", round(accuracy, 3), "\n")

```

## Large-Scale Simulation Study

Now let's run 10 simulations to assess SAASI's performance:

```{r run_simulations}
n_sims <- 10
results_list <- list()

cat("Running", n_sims, "simulations...\n")

set.seed(123)  # For reproducibility

for (i in 1:n_sims) {
  # Generate tree
  
  phy <- sim_bds_tree(
  params_df = demo_pars, 
  q_matrix = demo_Q, 
  x0 = 1,                    
  max_taxa = 200,             
  max_t = 50,                
  include_extinct = FALSE,   
  min_tip = 50               
)
  
  # For larger trees with better accuracy, uncomment the following:  
  
  # phy <- sim_bds_tree(
  #   params_df = demo_pars, 
  #   q_matrix = demo_Q, 
  #   x0 = 1,
  #   max_taxa = 10000,
  #   max_t = 1000,
  #   include_extinct = FALSE,
  #   min_tip = 500
  # )
  
  # Extract true states 
  true_states <- phy$node.state
  accuracy <- NA
  
  tryCatch({
  saasi_result <- saasi(phy = phy,           
                     q_matrix = demo_Q,                
                     lambda = c(3, 1.5, 1.5),       
                     mu = 0.1,               
                     psi = c(0.1,1.0,1.0),            
                     prior = NULL)    
    predicted_states <- apply(saasi_result, 1, which.max)
    accuracy <- mean(predicted_states == true_states)
  }, error = function(e) {
    cat("Error in simulation", i, ":", e$message, "\n")
  })
  
  results_list[[i]] <- data.frame(
    simulation = i,
    n_tips = length(phy$tip.label),
    accuracy = accuracy
  )
}

all_results <- do.call(rbind, results_list)

head(all_results,5)
```
